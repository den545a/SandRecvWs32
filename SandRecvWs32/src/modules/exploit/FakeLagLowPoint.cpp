#include "FakeLagLowPoint.h"
#include "modules/other/consts.h"
#include <ws2tcpip.h>
#include <vector>
#include <iostream>
#include <iomanip>
#include <sstream>
#include "modules/visual/gui.h"  
#include <mutex>

typedef INT(WINAPI* RealWSASend)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef INT(WSAAPI* RealWSARecv)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);

RealWSASend RealWSASendPtr = nullptr;
RealWSARecv RealWSARecvPtr = nullptr;

std::vector<std::string> blockedPacketLogs;
std::vector<std::string> filteredBlockedPacketLogs;

std::vector<unsigned char> sendByteFilter;
int minSendPacketSize = 0;
int maxSendPacketSize = 0;

std::vector<unsigned char> recvByteFilter;
int minRecvPacketSize = 0;
int maxRecvPacketSize = 0;

std::vector<std::string> packetLogs;  
std::vector<std::string> copiedPacketLogs;  
std::mutex logMutex;

void LogPacket(const char* direction, const char* data, int length, int packetId = -1) {
    std::ostringstream oss;
    oss << "[" << direction << "] Size: " << length << " bytes - ";
    for (int i = 0; i < length; i++) {
        oss << std::hex << std::setw(2) << std::setfill('0') << (int)(unsigned char)data[i] << " ";
    }
    std::string packetLog = oss.str();

    std::lock_guard<std::mutex> lock(logMutex);

    if (packetId != -1) {
        copiedPacketLogs.push_back(packetLog);
    }

    packetLogs.push_back(packetLog);
    if (packetLogs.size() > 10000) {
        packetLogs.erase(packetLogs.begin());
    }
}

bool ShouldBlockPacket(const std::vector<unsigned char>& packet, bool isSendPacket) {
    const std::vector<unsigned char>& filter = isSendPacket ? sendByteFilter : recvByteFilter;

    if (filter.empty()) return false;

    // Сравниваем пакеты по фильтру (можно добавить более сложную логику сравнения)
    for (size_t i = 0; i < packet.size() && i < filter.size(); i++) {
        if (packet[i] != filter[i]) {
            return false;
        }
    }

    return true;
}

INT WSAAPI MyWSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine) {
    for (DWORD i = 0; i < dwBufferCount; i++) {
        if (ShouldBlockPacket(std::vector<unsigned char>(lpBuffers[i].buf, lpBuffers[i].buf + lpBuffers[i].len), true)) {
            // Заблокировать отправку пакета
            return 0;
        }
        LogPacket("OUT", lpBuffers[i].buf, lpBuffers[i].len);
    }
    return RealWSASendPtr(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine);
}

INT WSAAPI MyWSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine) {
    int result = RealWSARecvPtr(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine);
    if (result == 0 && lpNumberOfBytesRecvd && *lpNumberOfBytesRecvd > 0) {
        for (DWORD i = 0; i < dwBufferCount; i++) {
            if (ShouldBlockPacket(std::vector<unsigned char>(lpBuffers[i].buf, lpBuffers[i].buf + *lpNumberOfBytesRecvd), false)) {
                // Заблокировать получение пакета
                return 0;
            }
            LogPacket("IN", lpBuffers[i].buf, *lpNumberOfBytesRecvd);
        }
    }
    return result;
}

void FakeLag::runModule() {
    HMODULE hModule = GetModuleHandleA("Ws2_32.dll");
    if (hModule) {
        void* RealWSASendP = GetProcAddress(hModule, "WSASend");
        if (RealWSASendP && MH_CreateHook(RealWSASendP, &MyWSASend, reinterpret_cast<void**>(&RealWSASendPtr)) == MH_OK) {
            MH_EnableHook(RealWSASendP);
        }

        void* RealWSARecvP = GetProcAddress(hModule, "WSARecv");
        if (RealWSARecvP && MH_CreateHook(RealWSARecvP, &MyWSARecv, reinterpret_cast<void**>(&RealWSARecvPtr)) == MH_OK) {
            MH_EnableHook(RealWSARecvP);
        }
    }
}
