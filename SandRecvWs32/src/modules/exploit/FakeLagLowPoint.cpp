#include "FakeLagLowPoint.h"
#include "modules/other/consts.h"
#include <ws2tcpip.h>
#include <vector>
#include <iostream>
#include <iomanip>
#include <sstream>
#include "modules/visual/gui.h"  
#include <mutex>

typedef INT(WINAPI* RealWSASend)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef INT(WSAAPI* RealWSARecv)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);

RealWSASend RealWSASendPtr = nullptr;
RealWSARecv RealWSARecvPtr = nullptr;

std::vector<unsigned char> sendByteFilter;
int minSendPacketSize = 0;
int maxSendPacketSize = 0;

std::vector<unsigned char> recvByteFilter;
int minRecvPacketSize = 0;
int maxRecvPacketSize = 0;

std::vector<std::string> packetLogs;  
std::vector<std::string> copiedPacketLogs;  
std::mutex logMutex;

void LogPacket(const char* direction, const char* data, int length, int packetId = -1) {
    // Создаем строку для лога
    std::ostringstream oss;
    oss << "[" << direction << "] Size: " << length << " bytes - ";
    for (int i = 0; i < length; i++) {
        oss << std::hex << std::setw(2) << std::setfill('0') << (int)(unsigned char)data[i] << " ";
    }
    std::string packetLog = oss.str();

    // Синхронизируем доступ к logMutex, чтобы избежать гонок при записи в packetLogs и copiedPacketLogs
    std::lock_guard<std::mutex> lock(logMutex);

    // Если есть пакет, который нужно скопировать, добавляем его в список copiedPacketLogs
    if (packetId != -1) {
        copiedPacketLogs.push_back(packetLog); // Копируем пакет
    }

    packetLogs.push_back(packetLog);
    if (packetLogs.size() > 100) {
        packetLogs.erase(packetLogs.begin());
    }
}

INT WSAAPI MyWSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine) {
    for (DWORD i = 0; i < dwBufferCount; i++) {
        LogPacket("OUT", lpBuffers[i].buf, lpBuffers[i].len);
    }
    return RealWSASendPtr(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine);
}

INT WSAAPI MyWSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine) {
    int result = RealWSARecvPtr(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine);
    if (result == 0 && lpNumberOfBytesRecvd && *lpNumberOfBytesRecvd > 0) {
        for (DWORD i = 0; i < dwBufferCount; i++) {
            LogPacket("IN", lpBuffers[i].buf, *lpNumberOfBytesRecvd);
        }
    }
    return result;
}

void FakeLag::runModule() {
    HMODULE hModule = GetModuleHandleA("Ws2_32.dll");
    if (hModule) {
        void* RealWSASendP = GetProcAddress(hModule, "WSASend");
        if (RealWSASendP && MH_CreateHook(RealWSASendP, &MyWSASend, reinterpret_cast<void**>(&RealWSASendPtr)) == MH_OK) {
            MH_EnableHook(RealWSASendP);
        }

        void* RealWSARecvP = GetProcAddress(hModule, "WSARecv");
        if (RealWSARecvP && MH_CreateHook(RealWSARecvP, &MyWSARecv, reinterpret_cast<void**>(&RealWSARecvPtr)) == MH_OK) {
            MH_EnableHook(RealWSARecvP);
        }
    }
}
